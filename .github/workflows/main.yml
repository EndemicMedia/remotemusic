name: Process PR with AWS Bedrock

on:
  pull_request:
    types: [opened, edited]
  pull_request_review_comment:
    types: [created, edited]
  issue_comment:
    types: [created, edited]

env:
  ACTIONS_STEP_DEBUG: true

jobs:
  process-pr:
    runs-on: ubuntu-latest
    if: github.event.issue.pull_request || github.event.pull_request
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'

      - name: Check Node.js version
        run: node --version

      - name: Install dependencies
        run: |
          npm init -y
          npm install @octokit/rest @aws-sdk/client-bedrock-runtime axios ignore

      - name: Verify installed packages
        run: npm list --depth=0

      - name: Create JavaScript files
        run: |
          cat << EOT > pr-processor.js
          const { BedrockClient } = require('./bedrock-client');
          const { GitHubClient } = require('./github-client');
          const { getRepositoryContent } = require('./utils');

          const MAX_REQUESTS = 10;

          function minifyContent(content) {
            content = content.replace(/\s+/g, ' ').trim();
            return content;
          }

          async function main() {
            try {
              const github = new GitHubClient(process.env.GITHUB_TOKEN);
              const bedrock = new BedrockClient(process.env.AWS_DEFAULT_REGION);

              const prDetails = await github.getPRDetails();
              console.log("Fetching repository content...");
              const repoContent = await getRepositoryContent();

              const repoContentString = Object.entries(repoContent)
                .map(([file, content]) => `File: ${file}\n\n${minifyContent(content)}`)
                .join('\n\n---\n\n');

              let promptText;
              if (prDetails.latestComment) {
                promptText = `Latest comment on the pull request:\n${prDetails.latestComment.body}`;
              } else {
                promptText = `Pull Request Description:\n${prDetails.description}`;
              }

              const initialPrompt = `
                You are an AI assistant tasked with suggesting changes to a GitHub repository based on a pull request comment or description.
                Below is the current structure and content of the repository, followed by the latest comment or pull request description.
                Please analyze the repository content and the provided text, then suggest appropriate changes.
                ${prDetails.imageBase64 ? "An image has been included in the comment or description. Please consider this image in your analysis and suggestions." : ""}

                Repository content (minified):
                ${repoContentString}
                
                Description/Comment:
                ${promptText}
                
                <instructions>
                Based on the repository content and the provided text, suggest changes to the codebase. 
                Format your response as a series of git commands that can be executed to make the changes.
                Each command should be on a new line and start with 'git'.
                For file content changes, use 'git add' followed by the file path, then provide the new content between <<<EOF and EOF>>> markers.
                Ensure all file paths are valid and use forward slashes.
                Consider the overall architecture and coding style of the existing codebase when suggesting changes.
                If not directly related to the requested changes, don't make code changes to those parts. we want to keep consistency and stability with each iteration
                If the provided text is vague, don't make any changes.
                If no changes are necessary or if the request is unclear, state so explicitly.
                When you have finished suggesting all changes, end your response with the line END_OF_SUGGESTIONS.
                </instructions>

                Base branch: ${prDetails.base_branch}
              `;

              console.log("Sending initial request to Claude 3.5...", initialPrompt);
              const claudeResponse = await bedrock.getCompleteResponse(initialPrompt, prDetails.imageBase64, MAX_REQUESTS);
              console.log("Received complete response from Claude 3.5. Processing...");

              await github.processClaudeResponse(claudeResponse);

              github.runCommand('git add -A');
              const diffOutput = github.runCommand('git diff --cached --name-only');
              
              console.log("diffOutput", diffOutput);
              if (diffOutput.trim()) {
                github.commitAndPushChanges(prDetails.head_branch);
                await github.createPRComment(prDetails, "Changes suggested by Claude 3.5 have been applied to this PR based on the latest comment. Please review the changes.");
              } else {
                console.log("No changes to commit.");
                await github.createPRComment(prDetails, "Claude 3.5 analyzed the latest comment and the repository content but did not suggest any changes.");
              }
            } catch (error) {
              console.error("An error occurred:", error);
              const github = new GitHubClient(process.env.GITHUB_TOKEN);
              const prDetails = await github.getPRDetails();
              await github.createPRComment(prDetails, `An error occurred while processing this PR with Claude 3.5: ${error.message}`);
              process.exit(1);
            }
          }

          main().catch(error => {
            console.error(error);
            process.exit(1);
          });
          EOT

          cat << EOT > github-client.js
          const { Octokit } = require("@octokit/rest");
          const fs = require('fs');
          const { execSync } = require('child_process');
          const path = require('path');
          const axios = require('axios');

          class GitHubClient {
            constructor(token) {
              this.octokit = new Octokit({ auth: token });
            }

            async getPRDetails() {
              console.log('Getting PR details...');
              const eventPath = process.env.GITHUB_EVENT_PATH;
              const event = JSON.parse(fs.readFileSync(eventPath, 'utf8'));
              
              let prNumber, owner, repo;
              if (event.issue && event.issue.pull_request) {
                prNumber = event.issue.number;
                owner = event.repository.owner.login;
                repo = event.repository.name;
              } else if (event.pull_request) {
                prNumber = event.pull_request.number;
                owner = event.repository.owner.login;
                repo = event.repository.name;
              } else {
                throw new Error('This event is not associated with a pull request');
              }

              const { data: pullRequest } = await this.octokit.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });

              const latestComment = await this.getLatestComment(owner, repo, prNumber);
              const imageUrl = this.extractImageUrl(latestComment ? latestComment.body : pullRequest.body);
              let imageBase64 = null;
              if (imageUrl) {
                imageBase64 = await this.downloadAndEncodeImage(imageUrl);
              }

              return {
                owner,
                repo,
                pull_number: prNumber,
                description: pullRequest.body,
                base_branch: pullRequest.base.ref,
                head_branch: pullRequest.head.ref,
                imageBase64,
                latestComment,
              };
            }

            async getLatestComment(owner, repo, pull_number) {
              const { data: comments } = await this.octokit.issues.listComments({
                owner,
                repo,
                issue_number: pull_number,
              });

              const { data: reviewComments } = await this.octokit.pulls.listReviewComments({
                owner,
                repo,
                pull_number,
              });

              const allComments = [...comments, ...reviewComments].sort((a, b) => 
                new Date(b.created_at) - new Date(a.created_at)
              );

              return allComments.length > 0 ? allComments[0] : null;
            }

            extractImageUrl(text) {
              if (!text) return null;
              const regex = /!\[.*?\]\((.*?)\)/;
              const match = text.match(regex);
              return match ? match[1] : null;
            }

            async downloadAndEncodeImage(url) {
              try {
                const response = await axios.get(url, { responseType: 'arraybuffer' });
                return Buffer.from(response.data, 'binary').toString('base64');
              } catch (error) {
                console.error('Error downloading image:', error);
                return null;
              }
            }

            runCommand(command) {
              console.log(`Running command: ${command}`);
              try {
                return execSync(command, { encoding: 'utf8' });
              } catch (error) {
                console.warn(`Error executing command: ${command}`);
                console.warn(error.stderr);
              }
            }

            processClaudeResponse(response) {
              console.log('Processing Claude response...');
              const commands = response.split('\n').filter(cmd => cmd.trim().startsWith('git'));
              for (const command of commands) {
                console.log(`Executing: ${command}`);
                if (command.startsWith('git add')) {
                  const filePath = command.split(' ').pop(); 
                  const contentStart = response.indexOf('<<<EOF', response.indexOf(command));
                  const contentEnd = response.indexOf('EOF>>>', contentStart);
                  if (contentStart === -1 || contentEnd === -1) {
                    console.error(`Invalid content markers for file: ${filePath}`);
                    continue;
                  }
                  const content = response.slice(contentStart + 6, contentEnd).trim();
                  
                  fs.mkdirSync(path.dirname(filePath), { recursive: true });
                  fs.writeFileSync(filePath, content);
                  console.log(`Updated ${filePath}`, fs.readFileSync(filePath, 'utf8'));
                } else {
                  console.log(`Executing: ${command}`);
                  const output = this.runCommand(command);
                  console.log(output);
                }
              }
            }

            commitAndPushChanges(baseBranch) {
              console.log('Committing and pushing changes...');
              this.runCommand('git config user.name github-actions');
              this.runCommand('git config user.email github-actions@github.com');
              this.runCommand('git commit -am "Apply changes suggested by Claude 3.5"');
              this.runCommand(`git push origin HEAD:${baseBranch}`);
            }

            async createPRComment(prDetails, body) {
              console.log('Creating PR comment...');
              await this.octokit.issues.createComment({
                owner: prDetails.owner,
                repo: prDetails.repo,
                issue_number: prDetails.pull_number,
                body
              }).then(({ data, headers, status }) => {
                console.log('Comment created');
              }).catch(err => {
                console.log(err)
              });
            }
          }

          module.exports = { GitHubClient };
          EOT

          cat << EOT > bedrock-client.js
          const { BedrockRuntimeClient, InvokeModelCommand } = require("@aws-sdk/client-bedrock-runtime");

          class BedrockClient {
            constructor(region) {
              this.client = new BedrockRuntimeClient({ region });
            }

            async invokeBedrock(prompt, imageBase64 = null, retries = 3) {
              const messages = [
                {
                  role: "user",
                  content: []
                }
              ];

              if (imageBase64) {
                messages[0].content.push({
                  type: "image",
                  source: {
                    type: "base64",
                    media_type: "image/jpeg",
                    data: imageBase64
                  }
                });
              }

              messages[0].content.push({
                type: "text",
                text: `
                  Human: ${prompt}
                  Assistant:
                `
              });

              const command = new InvokeModelCommand({
                modelId: "anthropic.claude-3-5-sonnet-20240620-v1:0",
                contentType: "application/json",
                accept: "application/json",
                body: JSON.stringify({ 
                  anthropic_version: "bedrock-2023-05-31",
                  max_tokens: 4000,
                  messages: messages
                })
              });

              try {
                const response = await this.client.send(command);
                const responseBody = JSON.parse(new TextDecoder().decode(response.body));
                return responseBody.content[0].text;
              } catch (error) {
                if (retries > 0) {
                  console.log(`Bedrock API call failed. Retrying in 5 seconds...`);
                  await new Promise(resolve => setTimeout(resolve, 5000));
                  return this.invokeBedrock(prompt, imageBase64, retries - 1);
                } else {
                  throw new Error(`Failed to invoke Bedrock after 3 attempts: ${error.message}`);
                }
              }
            }

            async getCompleteResponse(initialPrompt, imageBase64, maxRequests) {
              let fullResponse = '';
              let currentPrompt = initialPrompt;
              let requestCount = 0;

              while (requestCount < maxRequests) {
                requestCount++;
                console.log(`Making request ${requestCount} to Bedrock...`);
                
                let response;
                try {
                  response = await this.invokeBedrock(currentPrompt, requestCount === 1 ? imageBase64 : null);
                  console.log('Received response', response);
                  fullResponse += response;
                } catch (error) {
                  console.error('Error making request to Bedrock:', error);
                  break;
                }
                
                if (response.includes('END_OF_SUGGESTIONS')) {
                  console.log('Received end of suggestions signal.');
                  break;
                }

                const lastCompleteCommand = fullResponse.lastIndexOf('git');
                if (lastCompleteCommand === -1) {
                  throw new Error('No valid git commands found in the response.');
                }

                fullResponse = fullResponse.substring(0, lastCompleteCommand);
                currentPrompt = `${initialPrompt}\n\nPrevious response:\n${fullResponse}\n\nPlease continue from where you left off. Remember to end your response with END_OF_SUGGESTIONS when you have no more changes to suggest.`;
              }

              if (requestCount >= maxRequests) {
                console.warn(`Reached maximum number of requests (${maxRequests}). The response may be incomplete.`);
              }

              return fullResponse;
            }
          }

          module.exports = { BedrockClient };
          EOT

          cat << EOT > utils.js
          const fs = require('fs').promises;
          const path = require('path');
          const ignore = require('ignore');

          async function getRepositoryContent() {
            const ig = ignore().add(['.git', 'node_modules', '.github', "package-lock.json", "bedrock-client.js", "github-client.js", "pr-processor.js", "utils.js"]);
            const content = {};

            async function readDir(dir) {
              //const entries = await fs.readdir(dir, { with
              const entries = await fs.readdir(dir, { withFileTypes: true });
                for (const entry of entries) {
                  const fullPath = path.join(dir, entry.name);
                  const relativePath = path.relative(process.cwd(), fullPath);

                  if (ig.ignores(relativePath)) continue;

                  if (entry.isDirectory()) {
                    await readDir(fullPath);
                  } else {
                    const fileContent = await fs.readFile(fullPath, 'utf8');
                    content[relativePath] = fileContent;
                  }
                }
              }
            }

            await readDir(process.cwd());
            return content;
          }

          module.exports = { getRepositoryContent };
          EOT

      - name: Process PR with AWS Bedrock
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: us-east-1
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: node pr-processor.js

      - name: Handle errors
        if: failure()
        run: |
          echo "An error occurred during the PR processing."
          echo "Please check the logs for more details."

      - name: Clean up
        if: always()
        run: |
          rm -f pr-processor.js github-client.js bedrock-client.js utils.js
          git checkout -- .
          git clean -fd
